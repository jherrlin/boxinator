#+AUTHOR: John Herrlin
#+TITLE: Boxinator in clj/cljc/cljs
#+EMAIL: jherrlin [@] gmail [dot] com

* Overview

  This is an application written in Clojure/ClojureScript.

  In the "src" directory this 3 directories lives. Each of them have a specific purpose
  and here is a short description of them and the things they do.

** Client

   The client is running reagent/re-frame. Reagent is a small wrapper around React and
   re-frame is a library to use "single datastore". re-frame have events that mutates data
   and subscribers that listens to data/changes in re-frames "app-db" datastructure.

*** Routes

    The app have support for URL routes. When a route is visited a set of events are
    dispatched.

*** Form and layers

    "View A" is a form and is designed in different layers to provide indirection. The
    layers are:

    - =client/inputs.cljs=

      This is the lowest level of the form layers. It knows detail on how to work with the
      input. This is "raw" React and HTML. None of them have any state and they get all
      their data through props. In this level of detail we think about stuff like "Should
      we be able to react on onFocus?" or "Should there be a default placeholder for the
      input?"

    - =client/hocs.cljs=

      On the same layer level is the HOCs. The HOCs are composable higher order
      components. Each of this components takes another component as an argument and
      returns a new component. The HOCs are general components that could be used in many
      different places. For example the "label" HOC can be used on a text input to provide
      a label.

    - =client/input_forms.cljs=

      One level above =inputs.cljs= and =hocs.cljs= is the input-forms. input-forms are
      inputs and HOCS that are composed. For example the "text" component in input-forms
      is a HTML text input with a label on top, have colored markdown depending on how it
      validates and have the ability to auto focus. The text input-form is a pure
      component that only works with props. On this level of abstraction we think about
      stuff like: "Should the label in this text input form be able to have a '*' if the
      field is required?" or "Does this text input form need color markdown to show
      validation errors?".

    - =client/view-a.cljs=

      This is the top levels of the form abstraction. Here we declare what data each
      component works with. Each component in the form only subscribes on the app-db path
      that it needs. This to minimize the render cost. The highest level of the form
      abstraction is the "form" component that lives in =client/view-a.cljs=. This level
      only know about form and not about detail in its child components. It knows stuff
      such as where the formdata lives, if the save/validate button have been pressed. In
      this level of detail we think about stuff like: "What should happen if the form is
      not valid?" or "What happends when we press the 'Validate' button."

*** Table

    The code lives in "client/view-b.cljs".

    When the table view in "View B" is triggerd via a URL visit a dispatch event makes a
    HTTP GET request to the server to get all the boxes the server have saved in its
    database. It also starts a poll that each 20 seconds makes a new GET request to the
    server to fetch new boxes.

    The component have a subscriber that listens to a path in the app-db tree. If new
    boxes arive there the component rerenders and displays the new boxes.

*** Colour picker

    The colour picker cant do any kind of blue colour. When removing blue from r,g,b only
    red and green is left. The number range is from 0 to 255. This creates a two
    dimentional vector. X axis is green from 0 to 255 and Y is the red from 0 to 255. Each
    step in the axis increases by 5. The colour picker then have 2601 different colours to
    choose from.

** Server
*** Endpoints

    The server have 3 endpoints:

    - "/"

      This listens to request and returns the index page.

    - "/box"

      This endpoint supports a HTTP POST request that saves the data provides in the
      request body to the database. After save the enpoint returns a respons that contains
      all the boxes that the database know about.

    - "/boxes"

      This endpoint returns a respons that contains all the boxes that the database know
      about when it get a HTTP GET request.

*** Database

    The database is Datomic "A transactional database with a flexible data model, elastic
    scaling, and rich queries." [[https://www.datomic.com/][link]]. From my point of view this is an exelent database to
    use together with Clojure. The query language is datastructure driven, it have a
    schema and have a timeline built in.

** System

   This namespace contains specifications and functions that are shared between the client
   and the server. The filenames have an ending on "cljc", that declares that they can be
   read by both Clojure and ClojureScript. In =system/boxinator.cljs= we have something
   called an entity spec. A spec is declarative way to describe enteties. Specs can have
   generators attached to them. If they do you can generate data from the spec definition
   that conforms to the spec.

   Here is an example on how to generate a value from a ":color/g" entity.

   #+BEGIN_SRC clojure :results output code
     (s/def :color/g pos-int?)
     (gen/generate (s/gen :color/g)) ;; => 201
   #+END_SRC

   You can also validate data through specs:

   #+BEGIN_SRC clojure :results output code
     (s/def :color/g pos-int?)
     (s/valid? :color/g 201) ;; => true
   #+END_SRC

* Tests
** Overview

   There are three types of test in the test suite.

   - Unit tests

     Unit tests are a good way to document how a function should be used and is also a
     good way to provide regression safety.

   - Property/generative based testing

     A property based test describes the arguments a function takes and the output that it
     generates. Specs are a good way to describe the inputs and outputs.

     Here is an example that lives in =system/boxinator.cljc=:

     #+BEGIN_SRC clojure :results output code
       (s/fdef normalize-boxes
         :args (s/cat :xs (s/coll-of :boxinator/box))
         :ret :boxinator/boxes)
     #+END_SRC

     The example says that the function =normalize-boxes= takes a collection of
     =:boxinator/box= enteties as argument and returns a normalized map.

     When we run the tests on this. Test.check will run this function 1000 times with
     randomly generated data based out of out spec. If the "fdef normalize-boxes" dont
     conform to the rules. The test will fail.

     "test.check is a Clojure property-based testing tool inspired by QuickCheck."

   - Integration tests

     Uses a chrom webdriver to interact with the "real" application. It filles the form
     and validates that the data is saved in the database.

** How to run test suite
*** Locally

    You need Clojure and a chrome webdriver installed to run the test suite.

    Navigate to the root of the app and run:

    #+BEGIN_SRC shell :results output code
      clojure -Atest
    #+END_SRC

    If you take the time to do this, navigate to "test/integration/form-test.clj" and
    replace =:headless? true= to =:headless? false= before runnning the test. This will
    give a live overview of the integration test.

*** TODO Docker

    #+BEGIN_SRC text :results output code
      circleci@3c822ada5341:/app$ sudo npm install -g shadow-cljs && sudo shadow-cljs release app
      /usr/local/bin/shadow-cljs -> /usr/local/lib/node_modules/shadow-cljs/cli/runner.js
      + shadow-cljs@2.8.93
      added 90 packages from 104 contributors in 24.566s
      shadow-cljs - config: /app/shadow-cljs.edn
      shadow-cljs - socket connect failed, server process dead?
      shadow-cljs - starting via "clojure"
      ==============================================================================
      WARNING: The configured :source-paths in shadow-cljs.edn were ignored!
               When using :deps they must be configured in deps.edn
      ==============================================================================
      Error building classpath. Failed to read artifact descriptor for metosin:muuntaja:jar:0.6.6
      org.eclipse.aether.resolution.ArtifactDescriptorException: Failed to read artifact descriptor for metosin:muuntaja:jar:0.6.6
              at org.apache.maven.repository.internal.DefaultArtifactDescriptorReader.loadPom(DefaultArtifactDescriptorReader.java:255)
              at org.apache.maven.repository.internal.DefaultArtifactDescriptorReader.readArtifactDescriptor(DefaultArtifactDescriptorReader.java:171)
              at org.eclipse.aether.internal.impl.DefaultRepositorySystem.readArtifactDescriptor(DefaultRepositorySystem.java:255)
              at clojure.tools.deps.alpha.extensions.maven$eval787$fn__789.invoke(maven.clj:99)
              at clojure.lang.MultiFn.invoke(MultiFn.java:244)
              at clojure.tools.deps.alpha$expand_deps$fn__1191.invoke(alpha.clj:191)
              at clojure.tools.deps.alpha$expand_deps.invokeStatic(alpha.clj:190)
              at clojure.tools.deps.alpha$expand_deps.invoke(alpha.clj:168)
              at clojure.tools.deps.alpha$resolve_deps.invokeStatic(alpha.clj:236)
              at clojure.tools.deps.alpha$resolve_deps.invoke(alpha.clj:216)
              at clojure.tools.deps.alpha.script.make_classpath2$create_classpath.invokeStatic(make_classpath2.clj:56)
              at clojure.tools.deps.alpha.script.make_classpath2$create_classpath.invoke(make_classpath2.clj:48)
              at clojure.tools.deps.alpha.script.make_classpath2$run_core.invokeStatic(make_classpath2.clj:82)
              at clojure.tools.deps.alpha.script.make_classpath2$run_core.invoke(make_classpath2.clj:73)
              at clojure.tools.deps.alpha.script.make_classpath2$run.invokeStatic(make_classpath2.clj:102)
              at clojure.tools.deps.alpha.script.make_classpath2$run.invoke(make_classpath2.clj:96)
              at clojure.tools.deps.alpha.script.make_classpath2$_main.invokeStatic(make_classpath2.clj:147)
              at clojure.tools.deps.alpha.script.make_classpath2$_main.doInvoke(make_classpath2.clj:119)
              at clojure.lang.RestFn.applyTo(RestFn.java:137)
              at clojure.lang.Var.applyTo(Var.java:705)
              at clojure.core$apply.invokeStatic(core.clj:665)
              at clojure.main$main_opt.invokeStatic(main.clj:514)
              at clojure.main$main_opt.invoke(main.clj:510)
              at clojure.main$main.invokeStatic(main.clj:664)
              at clojure.main$main.doInvoke(main.clj:616)
              at clojure.lang.RestFn.applyTo(RestFn.java:137)
              at clojure.lang.Var.applyTo(Var.java:705)
              at clojure.main.main(main.java:40)
      Caused by: org.eclipse.aether.resolution.ArtifactResolutionException: Could not transfer artifact metosin:muuntaja:pom:0.6.6 from/to central (https://repo1.maven.org/maven2/): Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
              at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:424)
              at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:229)
              at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:207)
              at org.apache.maven.repository.internal.DefaultArtifactDescriptorReader.loadPom(DefaultArtifactDescriptorReader.java:240)
              ... 27 more
      Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Could not transfer artifact metosin:muuntaja:pom:0.6.6 from/to central (https://repo1.maven.org/maven2/): Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
              at org.eclipse.aether.connector.basic.ArtifactTransportListener.transferFailed(ArtifactTransportListener.java:52)
              at org.eclipse.aether.connector.basic.BasicRepositoryConnector$TaskRunner.run(BasicRepositoryConnector.java:369)
              at org.eclipse.aether.util.concurrency.RunnableErrorForwarder$1.run(RunnableErrorForwarder.java:75)
              at org.eclipse.aether.connector.basic.BasicRepositoryConnector$DirectExecutor.execute(BasicRepositoryConnector.java:644)
              at org.eclipse.aether.connector.basic.BasicRepositoryConnector.get(BasicRepositoryConnector.java:262)
              at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:499)
              at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:401)
              ... 30 more
      Caused by: javax.net.ssl.SSLException: Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
              at java.base/sun.security.ssl.Alert.createSSLException(Alert.java:133)
              at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:320)
              at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:263)
              at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:258)
              at java.base/sun.security.ssl.SSLSocketImpl.handleException(SSLSocketImpl.java:1313)
              at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:408)
              at org.apache.http.conn.ssl.SSLSocketFactory.createLayeredSocket(SSLSocketFactory.java:573)
              at org.apache.http.conn.ssl.SSLSocketFactory.connectSocket(SSLSocketFactory.java:557)
              at org.apache.http.conn.ssl.SSLSocketFactory.connectSocket(SSLSocketFactory.java:414)
              at org.apache.http.impl.conn.DefaultClientConnectionOperator.openConnection(DefaultClientConnectionOperator.java:180)
              at org.apache.http.impl.conn.ManagedClientConnectionImpl.open(ManagedClientConnectionImpl.java:326)
              at org.apache.http.impl.client.DefaultRequestDirector.tryConnect(DefaultRequestDirector.java:610)
              at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:445)
              at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:835)
              at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:72)
              at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
              at org.apache.http.impl.client.DecompressingHttpClient.execute(DecompressingHttpClient.java:164)
              at org.eclipse.aether.transport.http.HttpTransporter.execute(HttpTransporter.java:290)
              at org.eclipse.aether.transport.http.HttpTransporter.implGet(HttpTransporter.java:246)
              at org.eclipse.aether.spi.connector.transport.AbstractTransporter.get(AbstractTransporter.java:67)
              at org.eclipse.aether.connector.basic.BasicRepositoryConnector$GetTaskRunner.runTask(BasicRepositoryConnector.java:457)
              at org.eclipse.aether.connector.basic.BasicRepositoryConnector$TaskRunner.run(BasicRepositoryConnector.java:364)
              ... 35 more
      Caused by: java.lang.RuntimeException: Unexpected error: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
              at java.base/sun.security.validator.PKIXValidator.<init>(PKIXValidator.java:102)
              at java.base/sun.security.validator.Validator.getInstance(Validator.java:181)
              at java.base/sun.security.ssl.X509TrustManagerImpl.getValidator(X509TrustManagerImpl.java:300)
              at java.base/sun.security.ssl.X509TrustManagerImpl.checkTrustedInit(X509TrustManagerImpl.java:176)
              at java.base/sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:189)
              at java.base/sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:129)
              at java.base/sun.security.ssl.CertificateMessage$T12CertificateConsumer.checkServerCerts(CertificateMessage.java:629)
              at java.base/sun.security.ssl.CertificateStatus$CertificateStatusConsumer.consume(CertificateStatus.java:295)
              at java.base/sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:392)
              at java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:443)
              at java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:421)
              at java.base/sun.security.ssl.TransportContext.dispatch(TransportContext.java:177)
              at java.base/sun.security.ssl.SSLTransport.decode(SSLTransport.java:164)
              at java.base/sun.security.ssl.SSLSocketImpl.decode(SSLSocketImpl.java:1151)
              at java.base/sun.security.ssl.SSLSocketImpl.readHandshakeRecord(SSLSocketImpl.java:1062)
              at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:402)
              ... 51 more
      Caused by: java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty
              at java.base/java.security.cert.PKIXParameters.setTrustAnchors(PKIXParameters.java:200)
              at java.base/java.security.cert.PKIXParameters.<init>(PKIXParameters.java:120)
              at java.base/java.security.cert.PKIXBuilderParameters.<init>(PKIXBuilderParameters.java:104)
              at java.base/sun.security.validator.PKIXValidator.<init>(PKIXValidator.java:99)
              ... 66 more
    #+END_SRC

    Instructions on how to run the tests with docker:

    #+BEGIN_SRC shell :results output code
      docker pull circleci/clojure:openjdk-11-tools-deps-1.10.1.502-stretch-node-browsers
      docker run -p 8080:8080 -it -w /app -v $PWD:/app circleci/clojure:openjdk-11-tools-deps-1.10.1.502-stretch-node-browsers bash
      npm install -g shadow-cljs && shadow-cljs release app
      clojure -Atest
    #+END_SRC

* Run
** How to run app

   The esiest way is maybe to run the app in Docker

   #+BEGIN_SRC shell :results output code
     docker run -p 8080:8080 -it -w /app -v $PWD:/app circleci/clojure:openjdk-11-tools-deps-1.10.1.502-stretch-node-browsers bash
     java -cp target/boxinator.jar clojure.main -m server.core
   #+END_SRC

   Visit http://localhost:8080/#/addbox or http://localhost:8080/#/listboxes

   http://localhost:8080 gives a combined view together with a view of the app-db.

** How to build the app                                            :noexport:

   Install Clojure and Shadow-cljs and build the uberjar is built with:

   #+BEGIN_SRC shell :results output code
     shadow-cljs release app && clojure -Auberjar
   #+END_SRC

* Develop

  The application have been developed with Emacs, CIDER and Chromium.

  To continue the developemnt install Emacs and CIDER. Go to the project in Emacs and run
  =M-x= =cider-jack-in-clj&cljs=. After you have to REPLs go to =src/server/core.clj=.
  Eval the buffer and run the =(-main)= in to comment block.

* Update deps

  #+BEGIN_SRC shell :results output code
    clojure -Sdeps '{:deps {olical/depot {:mvn/version "1.8.4"}}}' -m depot.outdated.main
    clojure -Sdeps '{:deps {olical/depot {:mvn/version "1.8.4"}}}' -m depot.outdated.main --update
  #+END_SRC
